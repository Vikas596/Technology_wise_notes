1 - Create a directory and move to that directory
mkdir my-time-machine
cd my-time-machine

2- Initializing Git Repository
git init
output - 
Initialized empty Git repository in /home/labex/project/my-time-machine/.git/

3 - status of repo in git 
git status
output-
On branch master

No commits yet

nothing to commit (create/copy files and use "git add" to track)
4 - created new text file name message.txt with some content 
echo "Hello, Future Me" > message.txt

5 - cat command to show the content of file

cat message.txt

6 - The staging environment (or staging area) is like a waiting room for your changes.

You use it to tell Git exactly which files you want to include in your next commit.

This gives you control over what goes into your project history.

git add message.txt

7 - commit my first repo
git commit -m "Send a message to the future"

output - 

[master (root-commit) a1b2c3d] Send a message to the future
 1 file changed, 1 insertion(+)
 create mode 100644 message.txt

8 - log command to show the log of file

git log 

output 

commit a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9 (HEAD -> master)
Author: Your Name <your.email@example.com>
Date:   Mon Aug 7 10:00:00 2023 +0000

    Send a message to the future

Summery 

How to create a Git repository (your time machine) using git init
How to check the status of your repository with git status
How to create files and prepare them for commit using git add
How to create a commit (a save point in time) with git commit
How to view your project's history using git log


--------------------------------------------------------------------------------------------------------

Git Configuration (git config) â€“ Complete Overview
ðŸ”¹ What is git config?

git config is used to set, get, and manage Git settings at different levels:

System (entire system)

Global (current user)

Local (specific repository)

ðŸ”¹ Common Git Configuration Levels
Level	Scope
--system	All users on the system
--global	Current user
--local	Current repository
ðŸ”¹ Essential Git Configurations
1. User Identity
git config --global user.name "Your Name"
git config --global user.email "your.email@example.com"


Used to identify commit authorship.

2. Colored Output
git config --global color.ui auto


Improves readability of Git command outputs.

3. Default Editor
git config --global core.editor nano


Defines which editor Git uses for commit messages.

4. Line Ending Handling
git config --global core.autocrlf input


Prevents line-ending issues across different operating systems.

5. Git Aliases
git config --global alias.st status
git config --global alias.lg "log --color --graph --pretty=format:..."


Speeds up frequently used Git commands.

ðŸ”¹ Local Configuration Example
git config user.name "Lab User"


Overrides global settings for a specific repository.

âœ… Key Takeaways

Git configurations control behavior, identity, and usability

Global config applies everywhere

Local config is repo-specific

Aliases significantly boost productivity

--------------------------------------------------------------------------------------------------

day 4 --

Git Technology â€“ Staging Area & File Control
ðŸ”¹ 1. Git Staging Area

Definition:
The staging area is an intermediate step between the working directory and commit history. It allows selecting specific changes to include in a commit.

Command:

git add <file>

ðŸ”¹ 2. Ignoring Files with .gitignore

Definition:
.gitignore tells Git which files or patterns should not be tracked, such as logs, temp files, or secrets.

Example:

*.log

ðŸ”¹ 3. Viewing Changes Before Commit

Definition:
git diff shows line-by-line changes between the working directory and the staging area.

Command:

git diff

ðŸ”¹ 4. Unstaging Files

Definition:
Unstaging removes files from the staging area without deleting or modifying file content.

Command:

git restore --staged <file>

ðŸ”¹ 5. Checking Repository Status

Definition:
Displays the current state of files: staged, unstaged, and untracked.

Command:

git status

âœ… Summary

git add â†’ move changes to staging

.gitignore â†’ prevent unwanted files from tracking

git diff â†’ review changes safely

git restore --staged â†’ remove files from staging

------------------------------------------------------------------------------------------

Git Technology â€“ Branching & Merging
ðŸ”¹ What is a Git Branch?

A branch is a separate line of development that allows working on features without affecting the main codebase.

ðŸ”¹ Create a Branch
git branch <branch-name>

ðŸ”¹ Switch Branches
git checkout <branch-name>
# OR
git switch <branch-name>


âœ” git switch is newer and clearer (Git â‰¥ 2.23)

ðŸ”¹ Create & Switch in One Command
git checkout -b <branch-name>
# OR
git switch -c <branch-name>

ðŸ”¹ Merge Branches
git merge <branch-name>


Merges changes into the current branch.

ðŸ”¹ Delete a Branch
git branch -d <branch-name>


Deletes only if fully merged (safe delete).

git branch -D <branch-name>


Force delete (use carefully).

ðŸ”¹ View All Branches
git branch
git branch -a

âœ… Summary

Branches isolate work

Switching controls context

Merging integrates changes

Deleting keeps repo clean

------------------------------------------------------------------------------------------------------------

Day 6 

The Role of the ".git" Folder

When you run git init, Git creates a hidden folder called .git inside your project directory. This folder is the heart of your Git repository. Itâ€™s where Git stores everything it needs to keep track of your projectâ€™s changes and history. Although this folder is hidden and you donâ€™t need to interact with it directly, itâ€™s where all the behind-the-scenes work happens to manage version control.

The .git folder contains important files and directories that Git uses to store information about your projectâ€”like the changes you make, your projectâ€™s history, and metadata that helps Git do its job efficiently.

Example of Whatâ€™s Inside the .git Folder:

Hereâ€™s what the structure of the .git folder might look like:

Bash
Copy to clipboard
.git/
â”œâ”€â”€ HEAD
â”œâ”€â”€ config
â”œâ”€â”€ objects/
â”œâ”€â”€ refs/
â”œâ”€â”€ logs/
Letâ€™s break down what each of these parts does, keeping it simple:

HEAD: This file helps Git keep track of your current place in the project. It tells Git which version of the project youâ€™re working on right now.

config: This file contains settings specific to this Git repository, like information about how Git should behave or how your project is connected to other repositories (if any).

objects/: This folder stores the actual content of your project (files and changes) in a compressed format. Every time you save a change, Git creates new objects here to remember that version of your project.

refs/: This folder contains information that helps Git keep track of different points in your projectâ€™s history (like different "versions" or "states" of your project). You donâ€™t need to worry about this too much at the start.

logs/: This folder contains records of actions youâ€™ve taken, like when you save changes. It helps Git keep a log of what happened in your project over time.


Using ".gitignore" to Manage Untracked Files

In any Git project, there are often files or directories that you donâ€™t want to track in version control. These could include temporary files, logs, 
build outputs, or files that are a work in progress. To manage this, Git uses a special file called .gitignore, which lists patterns to tell Git which files to ignore. 
This helps ensure that unnecessary or sensitive files are not accidentally added to the repository.
 It's crucial to add and commit the .gitignore file to the repository to ensure consistent rules for ignoring files are applied throughout the project.


"git log": Viewing the Basic History of Your Project

After making several commits, itâ€™s useful to review the history of those changes. 
The git log command helps you do just that by showing a list of all the commits made in your project, along with important details like the author, date, and commit message.


They will see something like this:

Plain text
Copy to clipboard
commit 9d1e9b8f3b14fd93d69b64ae5b2f634344f5c620 (HEAD -> main)
Author: Alice <alice@example.com>
Date:   Fri Oct 16 09:42:15 2024 +0000

    Combine guest list and decorations

commit 2b6a19d5f45b8f3b14c34ea7f0a56e93047fbc12
Author: Bob <bob@example.com>
Date:   Thu Oct 15 14:23:37 2024 +0000

    Update menu for vegetarians


For each commit, thereâ€™s a long string of letters and numbers (such as 9d1e9b8f3b14fd93d69b64ae5b2f634344f5c620). 
This is the commit hashâ€”a unique identifier that Git generates for each commit. It allows you to reference or revert to this specific commit later if needed.
Then, you can see the author of the commit, the date when the commit was made, and the commit message, which describes the changes. 
In this case, Alice combined the guest list and decorations, and Bob updated the menu for vegetarians.
You may also notice (HEAD -> main) next to the first commit. This means that this commit is currently at the tip of the main branch, and "HEAD" is pointing to it.    


Advanced "git log": Efficiently Searching and Filtering History

For longer projects, scrolling through the entire commit history may not always be practical. If Alice and Bob want to focus only on the most recent changes, they can limit the number of commits displayed by running:

Bash
Copy to clipboard
git log -n 3
This command will show just the last 3 commits, allowing them to quickly review the latest updates without the need to sift through older commits.


In some cases, Alice or Bob may need to search for specific commits. They can filter the commit history by author or keyword to find relevant information. For example, if Bob wants to see only the commits he made, he can use:

Bash
Copy to clipboard
git log --author="Bob"
If they need to find commits related to a specific topic, such as updates to the menu, they can search by keyword in the commit messages. Running:

Bash
Copy to clipboard
git log --grep="menu"
will display all the commits that mention "menu" in their messages, helping them locate relevant changes efficiently.

Using "git commit --amend" to Fix Mistakes

Mistakes happen, and sometimes you might realize a commit message is unclear or a small change was left out of your last commit. 
This is where git commit --amend becomes useful.
With git commit --amend, you can rewrite the most recent commit, either to edit the commit message or to include additional changes
 that you've staged. This command will open your default text editor, allowing you to modify the commit message or add any staged changes to the commit.
When using git commit --amend, it's important to apply it in the right context: use it when the commit is still local and hasn't been shared 
with a remote repository. This ensures that your history remains clean without causing potential conflicts with othersâ€™ work. However, avoid using it after
 you've shared the commit, as it can rewrite history and create confusion.

By using git commit --amend, you incorporate the missing file and update the commit message in one step, ensuring that the commit history accurately reflects all
 the changes in a single, logical commit.