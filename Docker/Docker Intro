What is Docker? 

Docker is an open-source platform that automates the deployment, scaling, and management of applications within 
containers. It provides a lightweight and efficient way to package applications and their dependencies, ensuring 
consistency across different environments. By using Docker, developers can focus on writing code without worrying 
about compatibility issues arising from differences in operating systems or software versions. 

Why is Docker Useful?

Docker is highly advantageous for teams due to its ability to streamline the development and deployment processes. 
By encapsulating applications in containers, Docker ensures that software runs consistently regardless of where it's 
deployed—be it a developer's laptop, a test server, or a production environment.

Key Docker Concepts

Docker Images: Think of images as blueprints or templates for containers. Each image contains everything needed to run an application, 
including the code, runtime, libraries, and settings. Importantly, from a single Docker image, you can create multiple containers—much 
like how you can build several houses from one blueprint.

Docker Containers: Containers are running instances of Docker images. They are isolated environments that execute your application 
without affecting the host system, ensuring it runs the same way regardless of where it's deployed. You can create multiple containers from the same image, 
enabling different environments or configurations as needed.

Interacting with Docker: Engine, Daemon, and CLI
To effectively work with Docker, it's important to understand its architecture and how its main components interact. Here’s how these pieces fit together:

Docker Engine: This is the core part of Docker—a client-server application that enables you to build and run containers. The Docker Engine consists of two 
main components: the Docker Daemon and the Docker CLI, which communicate via a REST API.

Docker Daemon: Also known as dockerd, the Docker Daemon is a background service that manages Docker objects such as images, containers, networks, and volumes. 
It listens for API requests and performs the actions needed to build, run, and manage containers. The Daemon is responsible for the actual work of creating and running containers.

Docker CLI: The Docker Command Line Interface (CLI) is the tool you use to interact with Docker from your terminal. When you type a command starting with docker,
 the CLI sends your request to the Docker Daemon via the REST API. The CLI acts as the user-facing entry point for managing containers, images, and other Docker resources.

 Running Your First Docker Container
Running your first Docker container is an essential and often the first step when learning Docker. 
It provides a simple way to ensure your Docker setup is working correctly. The hello-world image is
 specially designed for this purpose; it's a minimal Docker image that, when run, displays a welcome 
 message to confirm that Docker is fully operational on your system.

To get started, open your terminal and type:

Bash
Copy to clipboard
# Run the hello-world Docker image
docker run hello-world
Here's what happens when you run this command:

Docker checks if the hello-world image is already on your computer.
If it isn't, Docker downloads it from a place called Docker Hub, an online library of pre-built images.
Once the image is ready, Docker starts the container and runs a small program that shows a welcome message.

Listing Docker Images
To see which Docker images are currently saved on your computer, use this command:

Bash
Copy to clipboard
# List all Docker images on your system
docker images
After you've run docker run hello-world, the docker images command should show:

Plain text
Copy to clipboard
REPOSITORY    TAG       IMAGE ID       CREATED         SIZE
hello-world   latest    d2c94e258dcb   17 months ago   13.3kB

Listing Running Containers
To find out which containers are running at the moment, use the command:

Bash
Copy to clipboard
# List currently running Docker containers
docker ps
Since the hello-world container stops right after showing its message, you won't see it running:

Plain text
Copy to clipboard
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES

Listing All Containers
To view all containers on your system, whether they are currently running or have been stopped, you can use the following command.

Bash
Copy to clipboard
# List all Docker containers, both running and stopped
docker ps -a
By adding the -a option, Docker will list all containers, not just the actively running ones. This command will display a comprehensive list of every container, showing those that have finished executing, like the hello-world container. For example, the output might look like this:

Plain text
Copy to clipboard
CONTAINER ID   IMAGE         COMMAND    CREATED              STATUS                          PORTS     NAMES
981fddc7cbd2   hello-world   "/hello"   About a minute ago   Exited (0) About a minute ago             tender_gagarin
Here's a beginner-friendly explanation of each column and the values you might see:

CONTAINER ID: A unique identifier for each container. This serves as a shorthand reference for Docker to perform operations on the container.
IMAGE: The Docker image that was used to create the container. In this case, "hello-world" was the image utilized.
COMMAND: The command that runs when the container starts. For the hello-world container, it executed "/hello".
CREATED: The time elapsed since the container was created. For example, "About a minute ago" indicates it was created within the last minute.
STATUS: Displays the current state of the container. "Exited (0)" means the container has finished running successfully, and the number "0" typically indicates no errors occurred.
PORTS: Lists any network ports the container is using to communicate with the outside world. This might be blank if no ports are configured.
NAMES: A user-friendly name automatically assigned to the container, such as "tender_gagarin". This name can be used to identify the container instead of the long CONTAINER ID.


-------------------------------------------------------------------------------------------------------------------------

Introduction to Docker Hub

Docker Hub is an online platform where you can find, download, and share Docker images. It acts as a centralized repository, making it easy to use various software
 without building images from scratch. You can search for and pull images for web servers, databases, and thousands of other applications, ranging from simple utilities
  to complex computing frameworks, covering a vast array of needs and uses.

Understanding the Run Command

As mentioned before, the docker run command allows you to create and start a container in one seamless step. While efficient, this command encompasses several underlying processes:

First, it checks if the specified image is available locally. If not, it pulls the image from Docker Hub or another registry.
Then, it creates a container based on the downloaded image.
Finally, it starts the created container immediately.

== Pulling an External Docker Image ==

A key feature of Docker is its ability to access a vast library of pre-built images from Docker Hub. You can download these images to your local machine using the docker pull command, which by default retrieves images from Docker Hub, unless specified otherwise.

== Creating a Container == 

After pulling an image, the next step is to create a container. The docker create command sets up a container from a downloaded image without starting it immediately, offering flexibility for configuring containers.

Here are two examples of creating a container without and with a name:

Bash
Copy to clipboard
# 1. Creating a container without specifying a name
docker create nginx

# 2. Creating a container with a custom name
docker create --name my-nginx nginx

Checking the Container Status: Created

After creating a container, you can check its status using the docker ps -a command.

For instance, you might see an output like this:

Plain text
Copy to clipboard
CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS    PORTS     NAMES
c49adf897b2a   nginx     "/docker-entrypoint.…"   3 minutes ago   Created             my-nginx
This indicates that the container's status is "Created", meaning it hasn't run any processes yet. Additionally, you can see the name my-nginx, which highlights the user-friendly identifier you've assigned, making it easier to manage the container.

Starting a Container

The docker start command is used to initiate an existing Docker container. Unlike docker run, which creates and starts a container in one step, docker start only handles the starting process, assuming the container is already created.

Using the earlier example, you have two options to start the my-nginx container:

Bash
Copy to clipboard
# Option 1: Start the container using the name
docker start my_nginx
# Output: my_nginx

# Option 2: Start the container using the container ID
docker start c49adf897b2a
# Output: c49adf897b2a

== Stopping a Running Container == 


After running the Nginx container, you might need to stop it at some point. The docker stop command works similarly to docker start, allowing you to use either the container's name or ID.

To stop the my-nginx container you can use one of the following options:

Bash
Copy to clipboard
# Option 1: Stop the container using the name
docker stop my-nginx
# Output: my-nginx

# Option 1: Stop the container using the container ID
docker stop c49adf897b2a
# Output: c49adf897b2a

==================================================================================================================

What is a Dockerfile?
A Dockerfile is essentially a set of instructions used to build a Docker image. It's a straightforward text document that outlines a series of commands to systematically assemble an image. This file should be named Dockerfile with an uppercase 'D' and no file extension. This naming convention allows Docker to automatically recognize and use it during the build process.

Basic Syntax of a Dockerfile

Let's explore the basic syntax of a Dockerfile, which outlines how your Docker image will be assembled. While there are numerous commands you can use, let's start with some key ones.

Each of these instructions plays a significant role in configuring your Docker image:

FROM: This instruction specifies the base image for your Dockerfile. Consider it the foundation upon which your image is built. For instance, you might start with an image like nginx or node based on your project requirements. Every Dockerfile begins with a FROM instruction, indicating the starting point of your image.

RUN: This command executes instructions in the shell during the image-building process. For example, you might use RUN to install software or apply system updates. These commands are executed once when you build the image, setting up the environment needed for your application.

COPY: This command is used to move files from your host machine into the image's filesystem. For instance, you might use COPY to add your website's HTML files into the web server's directory in the image, ensuring your application has the files it needs to run properly.

CMD: This instruction specifies the default command to run when your container starts. Unlike RUN, which executes during the image-building process, CMD runs when you launch the container. For instance, you might use CMD to start a web server or an application. It's the command that the container performs every time it starts up.

Where to Place Your Dockerfile?

Before we dive into writing a Dockerfile, let's understand the structure of our example project. For this lesson, we'll use a simple project consisting of a custom HTML file named index.html that we wish to serve using Nginx.

The project directory will look like this:

Copy to clipboard
/project-directory
  ├── Dockerfile
  └── index.html
While you can technically place your Dockerfile in different directories, best practice dictates that you should place it at the root of your project. This ensures ease of management and that Docker can accurately locate the Dockerfile when executing the build command. By keeping all related files in one directory, you streamline the build process and ensure Docker has immediate access to your specified context.

Step 1: Specify the Base Image with FROM
To begin writing our Dockerfile, we first use the FROM command to define the base image.

Dockerfile
Copy to clipboard
# Use the official nginx image as the base image
FROM nginx:1.27.2
This instruction sets the base image. Here, we're using nginx:1.27.2, indicating a specific version. Choosing a specific version helps to ensure stability and compatibility by preventing unexpected changes when the base image gets updated.

Step 2: Update the System with RUN
With the base image set, the next step is to utilize the RUN command to execute commands like installing software or applying updates.

Dockerfile
Copy to clipboard
# Use the official nginx image as the base image
FROM nginx:1.27.2

# Run an update using the package manager
RUN apt-get update
This command runs shell commands inside the image during the build process. In this context, apt-get update refreshes the package lists, ensuring you have the latest version information when you install any additional packages. These operations are captured in a new image layer.

Step 3: Add Files to the Image with COPY
With the system updated, we now leverage the COPY command to incorporate necessary files from your host system into the image.

Dockerfile
Copy to clipboard
# Use the official nginx image as the base image
FROM nginx:1.27.2

# Run an update using the package manager
RUN apt-get update

# Copy custom HTML file to the default nginx directory
COPY index.html /usr/share/nginx/html/
The COPY instruction transfers files or directories from your host file system into the Docker image. The syntax COPY <source> <destination> places index.html from the current directory to /usr/share/nginx/html/ in the image.

Step 4: Define the Container's Default Behavior with CMD
Finally, we employ the CMD command to define the container's behavior upon starting.

Dockerfile
Copy to clipboard
# Use the official nginx image as the base image
FROM nginx:1.27.2

# Run an update using the package manager
RUN apt-get update

# Copy custom HTML file to the default nginx directory
COPY index.html /usr/share/nginx/html/

# Set the default command to run when starting the container
CMD ["nginx", "-g", "daemon off;"]
This instruction sets the default executable to run when the container starts. We use an array syntax, ["executable", "param1", "param2"], as it avoids involving shell processing issues common in shell form. The command ["nginx", "-g", "daemon off;"] is used to instruct Nginx not to run as a background process (daemon) and instead to stay active in the foreground. By running in the foreground, Nginx continuously serves web content, which is necessary to keep the container running and responsive.

Building Your Custom Image

With our Dockerfile in place, it's time to build the custom image. We'll use the docker build command to turn our instructions into a working image.

Open your terminal, navigate to the directory with your Dockerfile, and together, let's run this command:


# Build custom image from Dockerfile
docker build -t custom-nginx .
When building a Docker image, each part of the docker build command plays a crucial role:

docker build Command: Used to create a Docker image from a Dockerfile by converting its instructions into a working image.

-t Option: Tags the image with a specified name, like custom-nginx, for easy identification and management.

. (Dot) at the End: Tells Docker to look in the current folder for the Dockerfile and any necessary files to build the image.