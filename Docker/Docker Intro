What is Docker? 

Docker is an open-source platform that automates the deployment, scaling, and management of applications within 
containers. It provides a lightweight and efficient way to package applications and their dependencies, ensuring 
consistency across different environments. By using Docker, developers can focus on writing code without worrying 
about compatibility issues arising from differences in operating systems or software versions. 

Why is Docker Useful?

Docker is highly advantageous for teams due to its ability to streamline the development and deployment processes. 
By encapsulating applications in containers, Docker ensures that software runs consistently regardless of where it's 
deployed—be it a developer's laptop, a test server, or a production environment.

Key Docker Concepts

Docker Images: Think of images as blueprints or templates for containers. Each image contains everything needed to run an application, 
including the code, runtime, libraries, and settings. Importantly, from a single Docker image, you can create multiple containers—much 
like how you can build several houses from one blueprint.

Docker Containers: Containers are running instances of Docker images. They are isolated environments that execute your application 
without affecting the host system, ensuring it runs the same way regardless of where it's deployed. You can create multiple containers from the same image, 
enabling different environments or configurations as needed.

Interacting with Docker: Engine, Daemon, and CLI
To effectively work with Docker, it's important to understand its architecture and how its main components interact. Here’s how these pieces fit together:

Docker Engine: This is the core part of Docker—a client-server application that enables you to build and run containers. The Docker Engine consists of two 
main components: the Docker Daemon and the Docker CLI, which communicate via a REST API.

Docker Daemon: Also known as dockerd, the Docker Daemon is a background service that manages Docker objects such as images, containers, networks, and volumes. 
It listens for API requests and performs the actions needed to build, run, and manage containers. The Daemon is responsible for the actual work of creating and running containers.

Docker CLI: The Docker Command Line Interface (CLI) is the tool you use to interact with Docker from your terminal. When you type a command starting with docker,
 the CLI sends your request to the Docker Daemon via the REST API. The CLI acts as the user-facing entry point for managing containers, images, and other Docker resources.

 Running Your First Docker Container
Running your first Docker container is an essential and often the first step when learning Docker. 
It provides a simple way to ensure your Docker setup is working correctly. The hello-world image is
 specially designed for this purpose; it's a minimal Docker image that, when run, displays a welcome 
 message to confirm that Docker is fully operational on your system.

To get started, open your terminal and type:

Bash
Copy to clipboard
# Run the hello-world Docker image
docker run hello-world
Here's what happens when you run this command:

Docker checks if the hello-world image is already on your computer.
If it isn't, Docker downloads it from a place called Docker Hub, an online library of pre-built images.
Once the image is ready, Docker starts the container and runs a small program that shows a welcome message.

Listing Docker Images
To see which Docker images are currently saved on your computer, use this command:

Bash
Copy to clipboard
# List all Docker images on your system
docker images
After you've run docker run hello-world, the docker images command should show:

Plain text
Copy to clipboard
REPOSITORY    TAG       IMAGE ID       CREATED         SIZE
hello-world   latest    d2c94e258dcb   17 months ago   13.3kB

Listing Running Containers
To find out which containers are running at the moment, use the command:

Bash
Copy to clipboard
# List currently running Docker containers
docker ps
Since the hello-world container stops right after showing its message, you won't see it running:

Plain text
Copy to clipboard
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES

Listing All Containers
To view all containers on your system, whether they are currently running or have been stopped, you can use the following command.

Bash
Copy to clipboard
# List all Docker containers, both running and stopped
docker ps -a
By adding the -a option, Docker will list all containers, not just the actively running ones. This command will display a comprehensive list of every container, showing those that have finished executing, like the hello-world container. For example, the output might look like this:

Plain text
Copy to clipboard
CONTAINER ID   IMAGE         COMMAND    CREATED              STATUS                          PORTS     NAMES
981fddc7cbd2   hello-world   "/hello"   About a minute ago   Exited (0) About a minute ago             tender_gagarin
Here's a beginner-friendly explanation of each column and the values you might see:

CONTAINER ID: A unique identifier for each container. This serves as a shorthand reference for Docker to perform operations on the container.
IMAGE: The Docker image that was used to create the container. In this case, "hello-world" was the image utilized.
COMMAND: The command that runs when the container starts. For the hello-world container, it executed "/hello".
CREATED: The time elapsed since the container was created. For example, "About a minute ago" indicates it was created within the last minute.
STATUS: Displays the current state of the container. "Exited (0)" means the container has finished running successfully, and the number "0" typically indicates no errors occurred.
PORTS: Lists any network ports the container is using to communicate with the outside world. This might be blank if no ports are configured.
NAMES: A user-friendly name automatically assigned to the container, such as "tender_gagarin". This name can be used to identify the container instead of the long CONTAINER ID.


-------------------------------------------------------------------------------------------------------------------------

Introduction to Docker Hub

Docker Hub is an online platform where you can find, download, and share Docker images. It acts as a centralized repository, making it easy to use various software
 without building images from scratch. You can search for and pull images for web servers, databases, and thousands of other applications, ranging from simple utilities
  to complex computing frameworks, covering a vast array of needs and uses.

Understanding the Run Command

As mentioned before, the docker run command allows you to create and start a container in one seamless step. While efficient, this command encompasses several underlying processes:

First, it checks if the specified image is available locally. If not, it pulls the image from Docker Hub or another registry.
Then, it creates a container based on the downloaded image.
Finally, it starts the created container immediately.

== Pulling an External Docker Image ==

A key feature of Docker is its ability to access a vast library of pre-built images from Docker Hub. You can download these images to your local machine using the docker pull command, which by default retrieves images from Docker Hub, unless specified otherwise.

== Creating a Container == 

After pulling an image, the next step is to create a container. The docker create command sets up a container from a downloaded image without starting it immediately, offering flexibility for configuring containers.

Here are two examples of creating a container without and with a name:

Bash
Copy to clipboard
# 1. Creating a container without specifying a name
docker create nginx

# 2. Creating a container with a custom name
docker create --name my-nginx nginx

Checking the Container Status: Created

After creating a container, you can check its status using the docker ps -a command.

For instance, you might see an output like this:

Plain text
Copy to clipboard
CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS    PORTS     NAMES
c49adf897b2a   nginx     "/docker-entrypoint.…"   3 minutes ago   Created             my-nginx
This indicates that the container's status is "Created", meaning it hasn't run any processes yet. Additionally, you can see the name my-nginx, which highlights the user-friendly identifier you've assigned, making it easier to manage the container.

Starting a Container

The docker start command is used to initiate an existing Docker container. Unlike docker run, which creates and starts a container in one step, docker start only handles the starting process, assuming the container is already created.

Using the earlier example, you have two options to start the my-nginx container:

Bash
Copy to clipboard
# Option 1: Start the container using the name
docker start my_nginx
# Output: my_nginx

# Option 2: Start the container using the container ID
docker start c49adf897b2a
# Output: c49adf897b2a

== Stopping a Running Container == 


After running the Nginx container, you might need to stop it at some point. The docker stop command works similarly to docker start, allowing you to use either the container's name or ID.

To stop the my-nginx container you can use one of the following options:

Bash
Copy to clipboard
# Option 1: Stop the container using the name
docker stop my-nginx
# Output: my-nginx

# Option 1: Stop the container using the container ID
docker stop c49adf897b2a
# Output: c49adf897b2a

==================================================================================================================

What is a Dockerfile?
A Dockerfile is essentially a set of instructions used to build a Docker image. It's a straightforward text document that outlines a series of commands to systematically assemble an image. This file should be named Dockerfile with an uppercase 'D' and no file extension. This naming convention allows Docker to automatically recognize and use it during the build process.

Basic Syntax of a Dockerfile

Let's explore the basic syntax of a Dockerfile, which outlines how your Docker image will be assembled. While there are numerous commands you can use, let's start with some key ones.

Each of these instructions plays a significant role in configuring your Docker image:

FROM: This instruction specifies the base image for your Dockerfile. Consider it the foundation upon which your image is built. For instance, you might start with an image like nginx or node based on your project requirements. Every Dockerfile begins with a FROM instruction, indicating the starting point of your image.

RUN: This command executes instructions in the shell during the image-building process. For example, you might use RUN to install software or apply system updates. These commands are executed once when you build the image, setting up the environment needed for your application.

COPY: This command is used to move files from your host machine into the image's filesystem. For instance, you might use COPY to add your website's HTML files into the web server's directory in the image, ensuring your application has the files it needs to run properly.

CMD: This instruction specifies the default command to run when your container starts. Unlike RUN, which executes during the image-building process, CMD runs when you launch the container. For instance, you might use CMD to start a web server or an application. It's the command that the container performs every time it starts up.

Where to Place Your Dockerfile?

Before we dive into writing a Dockerfile, let's understand the structure of our example project. For this lesson, we'll use a simple project consisting of a custom HTML file named index.html that we wish to serve using Nginx.

The project directory will look like this:

Copy to clipboard
/project-directory
  ├── Dockerfile
  └── index.html
While you can technically place your Dockerfile in different directories, best practice dictates that you should place it at the root of your project. This ensures ease of management and that Docker can accurately locate the Dockerfile when executing the build command. By keeping all related files in one directory, you streamline the build process and ensure Docker has immediate access to your specified context.

Step 1: Specify the Base Image with FROM
To begin writing our Dockerfile, we first use the FROM command to define the base image.

Dockerfile
Copy to clipboard
# Use the official nginx image as the base image
FROM nginx:1.27.2
This instruction sets the base image. Here, we're using nginx:1.27.2, indicating a specific version. Choosing a specific version helps to ensure stability and compatibility by preventing unexpected changes when the base image gets updated.

Step 2: Update the System with RUN
With the base image set, the next step is to utilize the RUN command to execute commands like installing software or applying updates.

Dockerfile
Copy to clipboard
# Use the official nginx image as the base image
FROM nginx:1.27.2

# Run an update using the package manager
RUN apt-get update
This command runs shell commands inside the image during the build process. In this context, apt-get update refreshes the package lists, ensuring you have the latest version information when you install any additional packages. These operations are captured in a new image layer.

Step 3: Add Files to the Image with COPY
With the system updated, we now leverage the COPY command to incorporate necessary files from your host system into the image.

Dockerfile
Copy to clipboard
# Use the official nginx image as the base image
FROM nginx:1.27.2

# Run an update using the package manager
RUN apt-get update

# Copy custom HTML file to the default nginx directory
COPY index.html /usr/share/nginx/html/
The COPY instruction transfers files or directories from your host file system into the Docker image. The syntax COPY <source> <destination> places index.html from the current directory to /usr/share/nginx/html/ in the image.

Step 4: Define the Container's Default Behavior with CMD
Finally, we employ the CMD command to define the container's behavior upon starting.

Dockerfile
Copy to clipboard
# Use the official nginx image as the base image
FROM nginx:1.27.2

# Run an update using the package manager
RUN apt-get update

# Copy custom HTML file to the default nginx directory
COPY index.html /usr/share/nginx/html/

# Set the default command to run when starting the container
CMD ["nginx", "-g", "daemon off;"]
This instruction sets the default executable to run when the container starts. We use an array syntax, ["executable", "param1", "param2"], as it avoids involving shell processing issues common in shell form. The command ["nginx", "-g", "daemon off;"] is used to instruct Nginx not to run as a background process (daemon) and instead to stay active in the foreground. By running in the foreground, Nginx continuously serves web content, which is necessary to keep the container running and responsive.

Building Your Custom Image

With our Dockerfile in place, it's time to build the custom image. We'll use the docker build command to turn our instructions into a working image.

Open your terminal, navigate to the directory with your Dockerfile, and together, let's run this command:


# Build custom image from Dockerfile
docker build -t custom-nginx .
When building a Docker image, each part of the docker build command plays a crucial role:

docker build Command: Used to create a Docker image from a Dockerfile by converting its instructions into a working image.

-t Option: Tags the image with a specified name, like custom-nginx, for easy identification and management.

. (Dot) at the End: Tells Docker to look in the current folder for the Dockerfile and any necessary files to build the image.

-----------------------------------------------------------------------------------------------------------------

Understanding Ports in Docker Containers

Before diving back into our Dockerfile, it's important to understand how ports operate within Docker containers. Ports act as communication endpoints that allow your containerized application to interact with external clients, like web browsers or other services.

When an application runs inside a container, it usually listens on specific network ports for incoming requests. By default, these ports are not accessible from outside the container. To allow external access, the ports must be mapped to ports on your host machine.

---Introducing the EXPOSE Command---

The EXPOSE command in a Dockerfile is a directive that specifies which ports an application inside the container listens on. For instance, if your application is a web server, you might use EXPOSE to indicate that it listens on port 80, the default port for HTTP traffic.


# Expose port 80
EXPOSE 80

Updating the Dockerfile
To ensure our Nginx server is set up correctly and ready for external communication, we'll update our Dockerfile. This updated version will include the command to expose the required port.


# Use the official nginx image as the base image
FROM nginx:1.27.2

# Run an update using the package manager
RUN apt-get update

# Copy custom HTML file to the default nginx directory
COPY index.html /usr/share/nginx/html/

# Expose port 80 for the Nginx server
EXPOSE 80

# Set the default command to run when starting the container
CMD ["nginx", "-g", "daemon off;"]
With this update, our Dockerfile clearly documents the intended port exposure for anyone using the image. Remember, whenever you change the Dockerfile, it's important to rebuild the image to incorporate those changes.

Running a Container with Port Mapping
With our newly built Docker image ready to go, let's run a container. To make port 80 accessible from our host system, we'll map it using the -p flag. This flag binds a local port to one exposed in your container.

To run the container, use the following command:


# Run the container and map port 80 in the container to port 8080 on the host
docker run -p 8080:80 custom-nginx
Here's what this command does:

The -p flag is for port mapping and shows us which ports are connected.
8080: This is the port on your computer (host) that we will use to access the service.
80: This is the port inside the container where the service is running.
By using 8080 on your computer and linking it to 80 inside the container, you allow requests to http://localhost:8080 to reach port 80 inside the container. This makes it easy to access the container's service from your web browser.

Starting a Container with Port Mapping
To execute a container with port mapping using docker start, you must first create the container with the appropriate settings. It's important to note that port mappings can only be set during the container creation process, not when starting an already created container.

Here's how you can achieve this:

Create the Container: Use docker create to set up the container and configure the port mappings.


# Create a container with port mapping and a custom name
docker create --name my-nginx -p 8080:80 custom-nginx
--name my-nginx assigns a custom name to the container for easier management.
-p 8080:80 maps port 80 inside the container to port 8080 on the host.
Start the Container: Once you've created the container with the desired port mappings, you can then start it using docker start:

# Start the previously created container
docker start my-nginx
Remember, if you need to adjust the port mappings, you'll need to create a new container with the desired settings.

Accessing the Running Container
To confirm your container is operational and serving content as intended, access the Nginx server via a web browser. Enter http://localhost:8080 in your browser's address bar. You should see the content of your index.html file displayed, confirming Nginx is properly serving your custom HTML file.

When an application runs inside a container, it listens on specific network ports for incoming requests. By default, applications are configured to listen on certain ports internally. For instance, the default Nginx image listens on port 80. This means that, regardless of how you configure the EXPOSE command in your Dockerfile or map the ports in your run command, the application will respond to its designated internal port unless you modify its configuration files, which requires code changes beyond this lesson's scope.

However, you can control which port on your host machine is used to access the container. Even though the application listens on a fixed port inside the container, you can map a different port on your host machine to this internal port using the -p flag in the run command, allowing flexibility in how external clients access your application.

Addressing Port Mapping Conflicts
When setting up port mapping for multiple containers, it's essential to understand that you cannot map different containers to the same host port unless they run on different network interfaces (IP addresses). Attempting to map multiple containers to the same host port will result in a conflict because the host port can only bind to one container at a time.

For example, if you're running several containers and all need to expose their service on the same container port, you must assign different host ports to each:

B
# Run the first container, mapping its port 80 to host port 8080
docker run -p 8080:80 custom-nginx

# Run the second container, mapping its port 80 to host port 8081
docker run -p 8081:80 custom-nginx
These commands ensure that each container's service is accessible and avoids conflicts by using separate host ports, allowing multiple instances of your service to coexist peacefully.

=====================================================================================================

Understanding Attached Mode
Let's begin with attached mode. When you run a container in attached mode, the container's standard input, output, and error streams are connected to your terminal session. This means you can see everything happening inside the container in real-time. It's like sitting in front of a computer and watching the screen as programs run. Attached mode is beneficial when you need to monitor logs, debug issues, or interactively work with the application inside the container.

For example, if you were running an Nginx server in attached mode, you might observe real-time log messages such as:


/docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration
/docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/
/docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh
10-listen-on-ipv6-by-default.sh: info: IPv6 listen already enabled
/docker-entrypoint.sh: Sourcing /docker-entrypoint.d/15-local-resolvers.envsh
/docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh
/docker-entrypoint.sh: Launching /docker-entrypoint.d/30-tune-worker-processes.sh
/docker-entrypoint.sh: Configuration complete; ready for start up
2024/10/16 13:54:44 [notice] 1#1: using the "epoll" event method
2024/10/16 13:54:44 [notice] 1#1: nginx/1.27.2
2024/10/16 13:54:44 [notice] 1#1: built by gcc 12.2.0 (Debian 12.2.0-14) 
2024/10/16 13:54:44 [notice] 1#1: OS: Linux 6.5.0-1018-aws
2024/10/16 13:54:44 [notice] 1#1: getrlimit(RLIMIT_NOFILE): 1048576:1048576
2024/10/16 13:54:44 [notice] 1#1: start worker processes
...
This output confirms that the Nginx configuration has been successfully processed, and the server is ready to handle requests.

Understanding Detached Mode
Now, let's look at detached mode. In contrast to attached mode, detached mode allows a container to run independently in the background, without tying up your terminal. Imagine starting a background task on your computer and allowing it to perform its operations while you continue using other applications. This mode is ideal for services that need to operate continuously without requiring your immediate attention.

When running a container in detached mode, you won't see its output directly in your terminal, but you can be confident that it's working silently in the background, performing its tasks. Instead, you receive a confirmation message like the container ID:


884fda246c7aec578f8476c6d96a602f518eda6869047c08ecf2560bfda92d78
This output indicates that the container is successfully running in the background, identified by its unique container ID.

Executing Containers with Docker Run
The docker run command is used to start new containers from an image. By default, when you execute a command like:

# Run a container in attached mode (default)
docker run nginx
It runs the container in attached mode, streaming messages and logs directly to your terminal. If you need the container to operate in the background, you can append the -d flag to run it in detached mode:


# Run a container in detached mode
docker run -d nginx
Using the -d flag switches the container to detached mode, allowing the terminal to be free for other operations while the container runs independently.

Executing Containers with Docker Start
The docker start command is used to start an existing, stopped container. By default, docker start runs the container in detached mode, meaning it will not tie up your terminal:


# Start an existing container in detached mode (default)
docker start <container-id-or-name>
If you want to attach your terminal to the running container to monitor outputs or interact with it, you can use:

# Start an existing container in attached mode
docker start -a <container-id-or-name>
The -a flag attaches the container's streams to your terminal, enabling direct interaction.

Viewing Logs of Containers in Detached Mode
When a container is running in detached mode, you don't directly see its output on your terminal. However, you can still access the logs using the docker logs command. This command allows you to fetch and view the container's stdout and stderr outputs, ensuring you can monitor its operations even when it's running in the background. For instance, if you want to view the logs of a container identified by its container ID or name, you can use:


# View logs of a container identified by container ID or name
docker logs <container-id-or-name>
This provides insight into the container's activities. To continuously monitor logs in real-time, you can use the -f flag:


# Continuously monitor logs in real-time
docker logs -f <container-id-or-name>
This approach is particularly handy for ongoing monitoring or diagnosing issues without needing to attach the container to your terminal. And don't worry, closing the terminal while using the docker logs command, including with the -f flag, won't affect the running container. It will continue its operations in detached mode, independent of your terminal session. For more insights and details, you can check out the official Docker logs documentation.

Combining Different Flags
When executing a command, such as docker run, it's essential to know how to combine various flags like -d for detached mode, -p for port mapping, and --name for assigning a specific name to the container. Here's an example:


# Run a container in detached mode with port mapping and a specific name
docker run -d -p 8080:80 --name my-nginx nginx
In this command, we combine flags to run the container in detached mode, map the container port to the host, and give it a specific name. You can arrange the flags in any order, but make sure to include all the ones you need to achieve the desired container setup.

Common Questions and Doubts
Here are some common questions and doubts regarding attached and detached modes:

Can I switch a running container from attached to detached mode or vice versa?

No, once a container is started in either attached or detached mode, you cannot switch directly between the two modes without stopping and restarting the container with the desired mode. If you need to change modes, stop the container and use the appropriate flags to start it again.
Are there performance differences between attached and detached modes?

The primary difference between attached and detached modes lies in how they interact with your terminal. There are no significant performance differences in how the container itself operates. The choice of mode depends on whether you need to interact with or monitor the container in real-time.
What happens if I close the terminal while a container is running in attached mode?

If you close the terminal session while a container is running in attached mode, the container will stop running because its input, output, and error streams are disconnected. This is one of the reasons why detached mode is useful for long-running processes. To keep a container running after closing the terminal, start it in detached mode.
Does a container retain its previous mode (attached or detached) when restarted with the docker start command?

When you restart a container using the docker start command, it defaults to detached mode unless you specify otherwise with the -a flag. This means the execution mode from the original start is not retained, and the default behavior is detached unless specifically overridden.